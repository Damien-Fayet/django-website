{% extends 'chessTrainer/base.html' %}
{% load chess_extras %}
{% load l10n %}

{% block extra_css %}
<link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
<style>
.chess-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

.statistics-box {
    border: 2px solid #dee2e6;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    background-color: #f8f9fa;
}

.move-table {
    font-family: 'Courier New', monospace;
}

.error-badge {
    font-size: 0.8em;
}

.chess-board-container {
    display: flex;
    gap: 20px;
    margin: 20px 0;
}

.chessboard-wrapper {
    flex: 0 0 400px;
}

.moves-panel {
    flex: 1;
    max-height: 600px;
    overflow-y: auto;
}

.move-item {
    padding: 8px 12px;
    margin: 2px 0;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
    border-left: 3px solid transparent;
}

.move-item:hover {
    background-color: #e9ecef;
}

.move-item.active {
    background-color: #007bff;
    color: white;
    border-left-color: #0056b3;
}

.move-number {
    font-weight: bold;
    color: #6c757d;
    min-width: 30px;
    display: inline-block;
}

.move-san {
    font-family: 'Courier New', monospace;
    font-weight: bold;
    min-width: 60px;
    display: inline-block;
}

.move-annotation {
    margin-left: 10px;
    font-size: 1.1em;
    font-weight: bold;
}

.best-moves {
    font-size: 0.8em;
    color: #6c757d;
    margin-top: 5px;
    padding-left: 20px;
}

.annotation-excellent { color: #28a745; }
.annotation-good { color: #17a2b8; }
.annotation-inaccuracy { color: #ffc107; }
.annotation-mistake { color: #fd7e14; }
.annotation-blunder { color: #dc3545; }

#chessboard {
    margin: 0 auto;
    width: 400px;
    height: 400px;
    position: relative;
}

/* Styles pour les fl√®ches de mouvement - Version Lichess */
.move-arrow {
    position: absolute;
    pointer-events: none;
    z-index: 1000;
}

.move-arrow svg {
    overflow: visible;
}

.arrow-line {
    stroke: #ff6b35;
    stroke-width: 6;
    opacity: 0.9;
    stroke-linecap: round;
}

.arrow-head {
    fill: #ff6b35;
    opacity: 0.9;
}

.cg-wrap {
    width: 400px;
    height: 400px;
    position: relative;
    display: block;
}

.lichess-board {
    border: 2px solid #ddd;
    border-radius: 4px;
}

.text-orange {
    color: #fd7e14 !important;
}
.bg-orange {
    background-color: #fd7e14 !important;
}
</style>
{% endblock %}

{% block title %}
    Analyse d√©taill√©e - Partie {{ chess_game.game_id|truncatechars:8 }}
{% endblock %}

{% block content %}
<style>
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

#analysisProgressContainer {
    border-left: 4px solid #0d6efd;
    background: linear-gradient(135deg, #e3f2fd 0%, #f8f9fa 100%);
}
</style>

<div class="chess-container">
    <div class="row">
        <div class="col-md-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1 class="h2 text-primary">
                    <i class="bi bi-graph-up"></i> Analyse Stockfish d√©taill√©e
                </h1>
                <div class="btn-group" role="group">
                    <a href="{% url 'chessTrainer:chess_analysis' %}" class="btn btn-outline-primary">
                        <i class="bi bi-house"></i> Accueil ChessTrainer
                    </a>
                    <a href="{% url 'chessTrainer:list_games' username=username %}" class="btn btn-outline-secondary">
                        <i class="bi bi-arrow-left"></i> Retour √† la liste
                    </a>
                    {% if chess_game.analyzed %}
                        <button type="button" class="btn btn-warning analyze-btn position-relative overflow-hidden" 
                                data-username="{{ chess_game.username }}" 
                                data-game-id="{{ chess_game.game_id }}" 
                                data-action="force-analyze"
                                id="btn-reanalyze-{{ chess_game.game_id }}"
                                style="min-width: 250px;">
                            <!-- Barre de progression en arri√®re-plan -->
                            <div class="progress-background position-absolute top-0 start-0 h-100 bg-success" 
                                 style="width: 0%; transition: width 0.3s ease; opacity: 0.3; z-index: 0;"></div>
                            <!-- Contenu du bouton -->
                            <span class="position-relative" style="z-index: 1;">
                                <i class="bi bi-arrow-clockwise"></i> 
                                <span class="button-text">Re-analyser</span>
                                <span class="progress-percentage" style="display: none;"></span>
                            </span>
                        </button>
                    {% endif %}
                </div>
            </div>
            
            <h3 class="text-secondary mb-3">Analyse de la partie {{ chess_game.game_id|truncatechars:8 }}</h3>
            
            <div class="card mb-3">
                <div class="card-header bg-primary text-white py-2">
                    <h5 class="mb-0"><i class="bi bi-info-circle"></i> Informations de la partie</h5>
                </div>
                <div class="card-body py-3">
                    <!-- Informations principales compactes -->
                    <div class="row align-items-center mb-2">
                        <div class="col-md-8">
                            <div class="d-flex flex-wrap gap-3">
                                <span>
                                    <span style="font-size: 1.1em;">‚ôô</span> <strong>{{ chess_game.white_player|default:"?" }}</strong> 
                                    <span class="text-muted">vs</span> 
                                    <span style="font-size: 1.1em;">‚ôü</span> <strong>{{ chess_game.black_player|default:"?" }}</strong>
                                </span>
                                <span><i class="bi bi-calendar3 text-secondary"></i> {{ chess_game.start_time|date:"d/m/Y H:i" }}</span>
                                <span><i class="bi bi-trophy text-secondary"></i> {{ chess_game.result|default:"En cours" }}</span>
                            </div>
                        </div>
                        <div class="col-md-4 text-end">
                            {% if chess_game.analyzed %}
                                <span class="badge bg-success"><i class="bi bi-check-circle"></i> Analys√©e</span>
                                <span class="badge bg-info">{{ average_accuracy|floatformat:1 }}% pr√©cision</span>
                            {% else %}
                                <span class="badge bg-warning"><i class="bi bi-exclamation-triangle"></i> Non analys√©e</span>
                            {% endif %}
                        </div>
                    </div>
                    
                    <!-- Statistiques de coups avec ic√¥nes -->
                    {% if chess_game.analyzed %}
                    <div class="border-top pt-2">
                        <div class="row g-2 text-center">
                            <div class="col-6 col-md-2">
                                <div class="d-flex align-items-center justify-content-center">
                                    <span class="me-1" style="font-size: 1.2em;">‚≠ê</span>
                                    <small class="text-success fw-bold">{{ best_moves_count }}</small>
                                </div>
                            </div>
                            <div class="col-6 col-md-2">
                                <div class="d-flex align-items-center justify-content-center">
                                    <span class="me-1" style="font-size: 1.2em;">üëç</span>
                                    <small class="text-primary fw-bold">{{ excellent_moves_count }}</small>
                                </div>
                            </div>
                            <div class="col-6 col-md-2">
                                <div class="d-flex align-items-center justify-content-center">
                                    <span class="me-1" style="font-size: 1.2em;">‚úì</span>
                                    <small class="text-secondary fw-bold">{{ good_moves_count }}</small>
                                </div>
                            </div>
                            <div class="col-6 col-md-2">
                                <div class="d-flex align-items-center justify-content-center">
                                    <span class="me-1" style="font-size: 1.2em;">?!</span>
                                    <small class="text-warning fw-bold">{{ inaccuracies_count }}</small>
                                </div>
                            </div>
                            <div class="col-6 col-md-2">
                                <div class="d-flex align-items-center justify-content-center">
                                    <span class="me-1" style="font-size: 1.2em;">‚ùå</span>
                                    <small class="text-danger fw-bold">{{ mistakes_count }}</small>
                                </div>
                            </div>
                            <div class="col-6 col-md-2">
                                <div class="d-flex align-items-center justify-content-center">
                                    <span class="me-1" style="font-size: 1.2em;">üí•</span>
                                    <small class="text-danger fw-bold">{{ blunders_count }}</small>
                                </div>
                            </div>
                        </div>
                    </div>
                    {% endif %}
                </div>
            </div>

            {% if chess_game.analyzed and chess_game.moves_data %}
            <div class="row">
                <!-- Colonne de gauche : √âchiquier et contr√¥les -->
                <div class="col-lg-6">
                    <!-- √âchiquier interactif -->
                    <div class="card">
                        <div class="card-header bg-primary text-white">
                            <h4 class="mb-0"><i class="bi bi-grid-3x3"></i> √âchiquier interactif</h4>
                        </div>
                        <div class="card-body">
                            <div id="chessboard" style="width: 100%; max-width: 400px; margin: 0 auto;"></div>
                            <div class="text-center mt-3">
                                <button id="startBtn" class="btn btn-outline-secondary btn-sm">D√©but</button>
                                <button id="prevBtn" class="btn btn-outline-secondary btn-sm">‚óÄ Pr√©c√©dent</button>
                                <button id="nextBtn" class="btn btn-outline-secondary btn-sm">Suivant ‚ñ∂</button>
                                <button id="endBtn" class="btn btn-outline-secondary btn-sm">Fin</button>
                            </div>
                            <div class="text-center mt-2">
                                <button id="prevErrorBtn" class="btn btn-outline-warning btn-sm">‚óÄ Mon Erreur Pr√©c.</button>
                                <button id="nextErrorBtn" class="btn btn-outline-warning btn-sm">Mon Erreur Suiv. ‚ñ∂</button>
                                <button id="nextBlunderBtn" class="btn btn-outline-danger btn-sm">üí• Ma Prochaine Gaffe</button>
                            </div>
                            <div class="mt-2 text-center">
                                <small id="moveInfo" class="text-muted">Position initiale</small>
                            </div>
                            <div class="mt-2 text-center">
                                <small class="text-muted">
                                    <strong>Raccourcis :</strong> ‚Üê ‚Üí (Navigation) | E (Erreur) | B (Gaffe) | Home/End
                                </small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Colonne de droite : Analyse des coups -->
                <div class="col-lg-6">
                    <!-- Analyse du coup courant -->
                    <div class="card" style="height: 600px;">
                        <div class="card-header bg-info text-white">
                            <h4 class="mb-0"><i class="bi bi-list-ol"></i> Analyse du coup courant</h4>
                        </div>
                        <div class="card-body">
                            <div id="currentMoveAnalysis">
                                <div class="text-center text-muted">
                                    <i class="bi bi-chess-pawn" style="font-size: 3rem;"></i>
                                    <h5 class="mt-3">Position initiale</h5>
                                    <p>Cliquez sur Suivant ou naviguez pour voir l'analyse des coups</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Graphique d'√©valuation en bas -->
            <div class="row mt-4">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header bg-success text-white">
                            <h4 class="mb-0"><i class="bi bi-graph-up"></i> Graphique d'√©valuation</h4>
                        </div>
                        <div class="card-body">
                            <canvas id="evaluationChart" width="400" height="100"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            {% else %}
                <div class="alert alert-info">
                    <h4><i class="bi bi-exclamation-circle"></i> Partie non analys√©e</h4>
                    <p>Cette partie n'a pas encore √©t√© analys√©e par Stockfish.</p>
                    <a href="{% url 'chessTrainer:analyze_specific_game' username=chess_game.username game_id=chess_game.game_id %}" class="btn btn-primary">
                        <i class="bi bi-play-circle"></i> Analyser maintenant
                    </a>
                </div>
            {% endif %}

        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script>
{% if chess_game.analyzed and chess_game.moves_data %}
document.addEventListener('DOMContentLoaded', function() {
    try {
        console.log("Initialisation de l'analyse d'√©checs...");
        
        // Variables globales pour la navigation
        const playerIsWhite = {{ player_is_white|yesno:"true,false" }};
        console.log(`Joueur analys√© joue les ${playerIsWhite ? 'Blancs' : 'Noirs'}`);
        
        // Donn√©es pour le graphique d'√©valuation
        const moveNumbers = [];
        const evaluations = [];
    
    {% for move_data in chess_game.moves_data %}
        moveNumbers.push({{ move_data.move_number|default:0 }});
        evaluations.push({{ move_data.evaluation_before|default:0|centipawns_to_pawns }});
    {% endfor %}
    
    const ctx = document.getElementById('evaluationChart').getContext('2d');
    const evaluationChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: moveNumbers,
            datasets: [{
                label: '√âvaluation',
                data: evaluations,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                tension: 0.4,
                pointRadius: 3,
                pointHoverRadius: 6
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: false,
                    title: {
                        display: true,
                        text: 'Pions'
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Num√©ro de coup'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    mode: 'index',
                    intersect: false
                }
            }
        }
    });

    // Initialisation de l'√©chiquier ChessBoard.js
    const game = new Chess();
    
    // Configuration de l'√©chiquier
    const config = {
        draggable: false,
        position: 'start',
        showNotation: true,
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
        orientation: '{{ orientation }}'
    };
    
    const board = Chessboard('chessboard', config);

    // Fonction pour ajouter une annotation sur l'√©chiquier
    function addMoveAnnotationToBoard(square, annotationType) {
        let color = '';
        let symbol = '';
        
        switch (annotationType) {
            case 'excellent':
                color = '#28a745';
                symbol = '‚òÖ';
                break;
            case 'inaccuracy':
                color = '#ffc107';
                symbol = '?!';
                break;
            case 'mistake':
                color = '#fd7e14';
                symbol = '?';
                break;
            case 'blunder':
                color = '#dc3545';
                symbol = '??';
                break;
            default:
                return; // Pas d'annotation pour les coups normaux
        }
        
        // Ajouter un symbole textuel sur la case
        setTimeout(() => {
            const boardElement = document.getElementById('chessboard');
            const existingSymbol = boardElement.querySelector(`[data-square-symbol="${square}"]`);
            if (existingSymbol) {
                existingSymbol.remove();
            }
            
            const squareElement = boardElement.querySelector(`[data-square="${square}"]`);
            if (squareElement) {
                const symbolElement = document.createElement('div');
                symbolElement.setAttribute('data-square-symbol', square);
                symbolElement.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    pointer-events: none;
                    font-weight: bold;
                    font-size: 14px;
                    color: white;
                    text-shadow: 1px 1px 2px black;
                    z-index: 1001;
                    width: 20px;
                    height: 20px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 50%;
                    background-color: ${color};
                `;
                symbolElement.textContent = symbol;
                
                squareElement.style.position = 'relative';
                squareElement.appendChild(symbolElement);
            }
        }, 200);
    }

    // Fonction pour supprimer toutes les annotations de l'√©chiquier
    function clearBoardAnnotations() {
        const boardElement = document.getElementById('chessboard');
        const symbols = boardElement.querySelectorAll('[data-square-symbol]');
        symbols.forEach(symbol => symbol.remove());
    }

    // Fonction pour effacer toutes les fl√®ches
    function clearMoveArrows() {
        const boardElement = document.getElementById('chessboard');
        const arrows = boardElement.querySelectorAll('.move-arrow');
        const arrowsSimple = boardElement.querySelectorAll('.move-arrow-simple');
        arrows.forEach(arrow => arrow.remove());
        arrowsSimple.forEach(arrow => arrow.remove());
    }

    // Fonction de debug pour inspecter la structure DOM de ChessBoard.js
    function debugChessboardStructure() {
        const boardElement = document.getElementById('chessboard');
        console.log('üîç DEBUG - Structure de l\'√©chiquier:', boardElement);
        
        if (boardElement) {
            console.log('üìè Dimensions √©chiquier:', {
                width: boardElement.offsetWidth,
                height: boardElement.offsetHeight,
                boundingRect: boardElement.getBoundingClientRect()
            });
            
            // Chercher les diff√©rents s√©lecteurs possibles pour les cases
            const dataSquares = boardElement.querySelectorAll('[data-square]');
            const classSquares = boardElement.querySelectorAll('[class*="square"]');
            
            console.log('üî≤ Cases trouv√©es:');
            console.log('  - data-square:', dataSquares.length, Array.from(dataSquares).slice(0, 3));
            console.log('  - class square:', classSquares.length, Array.from(classSquares).slice(0, 3));
            
            // Inspecter les classes CSS pr√©sentes
            const allElements = boardElement.querySelectorAll('*');
            const uniqueClasses = new Set();
            allElements.forEach(el => {
                if (el.className) {
                    el.className.split(' ').forEach(cls => {
                        if (cls.includes('square') || cls.length === 2) {
                            uniqueClasses.add(cls);
                        }
                    });
                }
            });
            
            console.log('üé® Classes CSS trouv√©es:', Array.from(uniqueClasses));
            
            // Essayer de trouver la case e4 sp√©cifiquement
            const e4Candidates = [
                boardElement.querySelector('[data-square="e4"]'),
                boardElement.querySelector('.square-e4'),
                boardElement.querySelector('.e4'),
                boardElement.querySelector('[class*="e4"]')
            ];
            
            console.log('üéØ Candidats pour e4:', e4Candidates);
        }
    }

    // Fonction pour obtenir les coordonn√©es exactes d'une case sur l'√©chiquier ChessBoard.js
    function getSquarePosition(square) {
        const boardElement = document.getElementById('chessboard');
        
        // ChessBoard.js utilise la classe .square-* pour identifier les cases
        let squareElement = boardElement.querySelector(`[data-square="${square}"]`);
        
        // Si data-square n'existe pas, essayer avec les classes CSS de ChessBoard.js
        if (!squareElement) {
            squareElement = boardElement.querySelector(`.square-${square}`);
        }
        
        if (squareElement) {
            const boardRect = boardElement.getBoundingClientRect();
            const squareRect = squareElement.getBoundingClientRect();
            
            const position = {
                x: squareRect.left - boardRect.left + squareRect.width / 2,
                y: squareRect.top - boardRect.top + squareRect.height / 2
            };
            
            console.log(`üìç Position trouv√©e pour ${square}:`, position, 'element:', squareElement);
            return position;
        }
        
        // Fallback : calcul manuel avec orientation correcte de l'√©chiquier
        const boardRect = boardElement.getBoundingClientRect();
        const squareSize = boardRect.width / 8;
        
        const file = square.charCodeAt(0) - 97; // a=0, b=1, ..., h=7
        const rank = parseInt(square[1]) - 1;   // 1=0, 2=1, ..., 8=7
        
        // Pour ChessBoard.js, l'√©chiquier est orient√© avec les blancs en bas
        const position = {
            x: file * squareSize + squareSize / 2,
            y: (7 - rank) * squareSize + squareSize / 2
        };
        
        console.log(`üìç Position calcul√©e pour ${square}:`, position, 'taille case:', squareSize);
        return position;
    }

    // Version alternative plus simple pour les fl√®ches
    function showMoveArrowSimple(fromSquare, toSquare) {
        console.log('ÔøΩ Version simple - Affichage fl√®che:', fromSquare, '->', toSquare);
        
        clearMoveArrows();
        
        const boardElement = document.getElementById('chessboard');
        if (!boardElement) {
            console.error('‚ùå √âchiquier non trouv√©');
            return;
        }
        
        // M√©thode simple avec calcul direct
        const boardSize = boardElement.offsetWidth;
        const squareSize = boardSize / 8;
        
        function getSquareCenter(square) {
            const file = square.charCodeAt(0) - 97; // a=0, b=1, etc.
            const rank = parseInt(square[1]) - 1;   // 1=0, 2=1, etc.
            
            return {
                x: file * squareSize + squareSize / 2,
                y: (7 - rank) * squareSize + squareSize / 2
            };
        }
        
        const from = getSquareCenter(fromSquare);
        const to = getSquareCenter(toSquare);
        
        console.log('üìê Coordonn√©es simples:', { from, to, boardSize, squareSize });
        
        // Cr√©er un div simple avec une fl√®che CSS
        const arrow = document.createElement('div');
        arrow.className = 'move-arrow-simple';
        arrow.style.position = 'absolute';
        arrow.style.left = from.x + 'px';
        arrow.style.top = from.y + 'px';
        arrow.style.width = '20px';
        arrow.style.height = '20px';
        arrow.style.backgroundColor = '#ff6b35';
        arrow.style.borderRadius = '50%';
        arrow.style.zIndex = '1001';
        arrow.style.opacity = '0.8';
        arrow.style.pointerEvents = 'none';
        arrow.innerHTML = '‚Üí';
        arrow.style.display = 'flex';
        arrow.style.alignItems = 'center';
        arrow.style.justifyContent = 'center';
        arrow.style.color = 'white';
        arrow.style.fontWeight = 'bold';
        
        boardElement.appendChild(arrow);
        console.log('‚úÖ Fl√®che simple cr√©√©e');
        
        // Ajouter aussi la fl√®che de destination
        const arrowTo = document.createElement('div');
        arrowTo.className = 'move-arrow-simple';
        arrowTo.style.position = 'absolute';
        arrowTo.style.left = to.x + 'px';
        arrowTo.style.top = to.y + 'px';
        arrowTo.style.width = '20px';
        arrowTo.style.height = '20px';
        arrowTo.style.backgroundColor = '#ff6b35';
        arrowTo.style.borderRadius = '50%';
        arrowTo.style.zIndex = '1001';
        arrowTo.style.opacity = '0.8';
        arrowTo.style.pointerEvents = 'none';
        arrowTo.innerHTML = '‚óè';
        arrowTo.style.display = 'flex';
        arrowTo.style.alignItems = 'center';
        arrowTo.style.justifyContent = 'center';
        arrowTo.style.color = 'white';
        arrowTo.style.fontWeight = 'bold';
        
        boardElement.appendChild(arrowTo);
    }

    // Fonction principale pour afficher une fl√®che de mouvement (style Lichess)
    function showMoveArrow(fromSquare, toSquare) {
        console.log('üèπ Affichage fl√®che style Lichess:', fromSquare, '‚Üí', toSquare);
        
        // Debug de la structure pour comprendre le probl√®me
        debugChessboardStructure();
        
        clearMoveArrows();
        
        const boardElement = document.getElementById('chessboard');
        if (!boardElement) {
            console.error('‚ùå √âchiquier non trouv√©');
            return;
        }
        
        const fromPos = getSquarePosition(fromSquare);
        const toPos = getSquarePosition(toSquare);
        
        if (!fromPos || !toPos) {
            console.error('‚ùå Impossible de calculer les positions');
            return;
        }
        
        // Calculer la g√©om√©trie de la fl√®che
        const dx = toPos.x - fromPos.x;
        const dy = toPos.y - fromPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        // R√©duire la longueur pour que la fl√®che ne touche pas les bords des cases
        const margin = 15;
        const adjustedDistance = Math.max(0, distance - 2 * margin);
        const startX = fromPos.x + margin * Math.cos(angle);
        const startY = fromPos.y + margin * Math.sin(angle);
        const endX = toPos.x - margin * Math.cos(angle);
        const endY = toPos.y - margin * Math.sin(angle);
        
        // Cr√©er le conteneur SVG
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'move-arrow');
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '1000';
        
        // Cr√©er la ligne de la fl√®che
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', startX);
        line.setAttribute('y1', startY);
        line.setAttribute('x2', endX);
        line.setAttribute('y2', endY);
        line.setAttribute('class', 'arrow-line');
        
        // Cr√©er la pointe de la fl√®che
        const arrowHeadLength = 20;
        const arrowHeadWidth = 12;
        
        const headAngle1 = angle + Math.PI - 0.3;
        const headAngle2 = angle + Math.PI + 0.3;
        
        const head1X = endX + arrowHeadLength * Math.cos(headAngle1);
        const head1Y = endY + arrowHeadLength * Math.sin(headAngle1);
        const head2X = endX + arrowHeadLength * Math.cos(headAngle2);
        const head2Y = endY + arrowHeadLength * Math.sin(headAngle2);
        
        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        arrowHead.setAttribute('points', `${endX},${endY} ${head1X},${head1Y} ${head2X},${head2Y}`);
        arrowHead.setAttribute('class', 'arrow-head');
        
        // Assembler la fl√®che
        svg.appendChild(line);
        svg.appendChild(arrowHead);
        boardElement.appendChild(svg);
        
        console.log('‚úÖ Fl√®che cr√©√©e:', {
            from: fromPos,
            to: toPos,
            distance: distance,
            angle: angle * 180 / Math.PI,
            startPoint: { x: startX, y: startY },
            endPoint: { x: endX, y: endY }
        });
    }

    // Version temporaire : surbrillance des cases au lieu de fl√®che
    function highlightMove(fromSquare, toSquare) {
        console.log('üéØ Surbrillance des cases:', fromSquare, '‚Üí', toSquare);
        
        clearMoveArrows();
        
        const boardElement = document.getElementById('chessboard');
        if (!boardElement) {
            console.error('‚ùå √âchiquier non trouv√©');
            return;
        }
        
        // Essayer diff√©rents s√©lecteurs pour trouver les cases
        function findSquareElement(square) {
            const selectors = [
                `[data-square="${square}"]`,
                `.square-${square}`,
                `.${square}`,
                `[class*="${square}"]`
            ];
            
            for (const selector of selectors) {
                const element = boardElement.querySelector(selector);
                if (element) {
                    console.log(`‚úÖ Case ${square} trouv√©e avec s√©lecteur: ${selector}`, element);
                    return element;
                }
            }
            
            console.log(`‚ùå Case ${square} non trouv√©e`);
            return null;
        }
        
        const fromElement = findSquareElement(fromSquare);
        const toElement = findSquareElement(toSquare);
        
        if (fromElement) {
            const fromHighlight = document.createElement('div');
            fromHighlight.className = 'move-arrow-simple move-highlight-from';
            fromHighlight.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(255, 107, 53, 0.4);
                border: 3px solid #ff6b35;
                box-sizing: border-box;
                pointer-events: none;
                z-index: 999;
            `;
            fromElement.style.position = 'relative';
            fromElement.appendChild(fromHighlight);
        }
        
        if (toElement) {
            const toHighlight = document.createElement('div');
            toHighlight.className = 'move-arrow-simple move-highlight-to';
            toHighlight.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(255, 107, 53, 0.6);
                border: 3px solid #ff6b35;
                box-sizing: border-box;
                pointer-events: none;
                z-index: 999;
            `;
            toElement.style.position = 'relative';
            toElement.appendChild(toHighlight);
        }
    }

    function uciToSan(uciMove, gamePosition) {
        try {
            // V√©rifier si c'est d√©j√† du SAN (contient des lettres majuscules ou des symboles d'√©checs)
            if (/[NBRQK]|[+#=]|O-O/.test(uciMove) || uciMove.length < 4) {
                return uciMove; // D√©j√† en SAN
            }
            
            const tempGame = new Chess(gamePosition.fen());
            
            // Essayer de jouer le coup UCI
            const move = tempGame.move(uciMove, { sloppy: true });
            if (move && move.san) {
                return move.san;
            }
            
            // Si √ßa ne marche pas, essayer d'autres formats
            console.log(`Tentative alternative pour: ${uciMove}`);
            
            // Essayer avec promotion explicite pour les pions
            if (uciMove.length === 5 && /[qrbn]$/.test(uciMove)) {
                const moveWithPromotion = tempGame.move({
                    from: uciMove.slice(0, 2),
                    to: uciMove.slice(2, 4),
                    promotion: uciMove.slice(4, 5)
                });
                if (moveWithPromotion) {
                    console.log(`Conversion avec promotion: ${uciMove} -> ${moveWithPromotion.san}`);
                    return moveWithPromotion.san;
                }
            }
            
            // Essayer le format objet
            const moveObj = tempGame.move({
                from: uciMove.slice(0, 2),
                to: uciMove.slice(2, 4)
            });
            
            if (moveObj) {
                console.log(`Conversion format objet: ${uciMove} -> ${moveObj.san}`);
                return moveObj.san;
            }
            
            console.warn(`Impossible de convertir: ${uciMove}`);
            return uciMove;
            
        } catch (e) {
            console.error(`Erreur conversion UCI->SAN: ${uciMove}`, e);
            return uciMove;
        }
    }

    // Donn√©es des coups
    const moves = [
        {% for move_data in chess_game.moves_data %}
        {
            san: '{{ move_data.move_san|default:"" }}',
            moveNumber: {{ move_data.move_number|default:0 }},
            isWhiteMove: {{ move_data.is_white_move|yesno:"true,false" }},
            plyCount: {{ move_data.ply_count|default:0 }},
            isBestMove: {{ move_data.is_best_move|yesno:"true,false" }},
            centipawnLoss: {{ move_data.centipawn_loss|default:0 }},
            accuracy: {{ move_data.accuracy|default:100|unlocalize }},
            evaluationBefore: {{ move_data.evaluation_before|default:0 }},
            evaluationAfter: {{ move_data.evaluation_after|default:0 }},
            moveQuality: '{{ move_data.move_quality|default:"acceptable" }}',
            qualityIcon: '{{ move_data.quality_icon|default:"‚úì" }}',
            qualityText: '{{ move_data.quality_text|default:"Coup acceptable" }}',
            topMoves: [
                {% for top_move in move_data.top_moves %}
                {
                    move: '{{ top_move.move|default:"" }}',
                    evaluation: {{ top_move.evaluation|default:0 }},
                    pv_line: [
                        {% for pv_move in top_move.pv_line %}
                        {
                            uci: '{{ pv_move.uci|default:"" }}',
                            san: '{{ pv_move.san|default:"" }}',
                            move_number: {{ pv_move.move_number|default:1 }},
                            is_white: {{ pv_move.is_white|yesno:"true,false" }}
                        }{% if not forloop.last %},{% endif %}
                        {% empty %}
                        {% endfor %}
                    ]
                }{% if not forloop.last %},{% endif %}
                {% empty %}
                {% endfor %}
            ],
            opponentPunishment: {% if move_data.opponent_punishment %}
            {
                move_san: '{{ move_data.opponent_punishment.move_san|default:"" }}',
                evaluation: {{ move_data.opponent_punishment.evaluation|default:0 }},
                pv_line: [
                    {% for pv_move in move_data.opponent_punishment.pv_line %}
                    {
                        uci: '{{ pv_move.uci|default:"" }}',
                        san: '{{ pv_move.san|default:"" }}',
                        move_number: {{ pv_move.move_number|default:1 }},
                        is_white: {{ pv_move.is_white|yesno:"true,false" }}
                    }{% if not forloop.last %},{% endif %}
                    {% empty %}
                    {% endfor %}
                ]
            }{% else %}null{% endif %}
        }{% if not forloop.last %},{% endif %}
        {% endfor %}
    ];

    let currentMoveIndex = -1; // -1 = position initiale

    // Fonction pour formater la notation d'√©checs correctement
    function formatMoveNotation(move) {
        if (move.isWhiteMove) {
            return `${move.moveNumber}. ${move.san}`;
        } else {
            return `${move.moveNumber}... ${move.san}`;
        }
    }

    // Fonction pour mettre √† jour l'√©tat des boutons de navigation
    function updateNavigationButtons() {
        // Boutons de navigation classiques
        document.getElementById('startBtn').disabled = (currentMoveIndex === -1);
        document.getElementById('prevBtn').disabled = (currentMoveIndex <= -1);
        document.getElementById('nextBtn').disabled = (currentMoveIndex >= moves.length - 1);
        document.getElementById('endBtn').disabled = (currentMoveIndex === moves.length - 1);
        
        // Boutons de navigation vers les erreurs
        const hasNextError = findNextError(currentMoveIndex) !== -1;
        const hasPrevError = findPrevError(currentMoveIndex) !== -1;
        const hasNextBlunder = findNextBlunder(currentMoveIndex) !== -1;
        
        document.getElementById('nextErrorBtn').disabled = !hasNextError;
        document.getElementById('prevErrorBtn').disabled = !hasPrevError;
        document.getElementById('nextBlunderBtn').disabled = !hasNextBlunder;
        
        // Mettre √† jour le texte du bouton avec le nombre d'erreurs restantes DU JOUEUR
        const remainingErrors = moves.slice(currentMoveIndex + 1).filter(move => 
            ['inaccuracy', 'mistake', 'blunder'].includes(move.moveQuality) && move.isWhiteMove === playerIsWhite
        ).length;
        const remainingBlunders = moves.slice(currentMoveIndex + 1).filter(move => 
            move.moveQuality === 'blunder' && move.isWhiteMove === playerIsWhite
        ).length;
        
        if (remainingErrors > 0) {
            document.getElementById('nextErrorBtn').innerHTML = `Mon Erreur Suiv. ‚ñ∂ (${remainingErrors})`;
        } else {
            document.getElementById('nextErrorBtn').innerHTML = 'Mon Erreur Suiv. ‚ñ∂';
        }
        
        if (remainingBlunders > 0) {
            document.getElementById('nextBlunderBtn').innerHTML = `üí• Ma Prochaine Gaffe (${remainingBlunders})`;
        } else {
            document.getElementById('nextBlunderBtn').innerHTML = 'üí• Ma Prochaine Gaffe';
        }
    }

    function updateMoveInfo() {
        const moveInfo = document.getElementById('moveInfo');
        const currentMoveAnalysis = document.getElementById('currentMoveAnalysis');
        
        // Mettre √† jour l'√©tat des boutons de navigation
        updateNavigationButtons();
        
        if (currentMoveIndex === -1) {
            moveInfo.textContent = 'Position initiale';
            clearBoardAnnotations();
            currentMoveAnalysis.innerHTML = `
                <div class="text-center text-muted">
                    <i class="bi bi-chess-pawn" style="font-size: 3rem;"></i>
                    <h5 class="mt-3">Position initiale</h5>
                    <p>Cliquez sur Suivant pour commencer l'analyse</p>
                </div>
            `;
        } else {
            const move = moves[currentMoveIndex];
            let annotation = move.qualityIcon;
            let annotationClass = '';
            let qualityText = move.qualityText;
            let boardAnnotationType = null;
            
            // D√©finir les classes CSS et annotations d'√©chiquier selon la qualit√©
            switch (move.moveQuality) {
                case 'best':
                    annotationClass = 'annotation-excellent';
                    boardAnnotationType = 'excellent';
                    break;
                case 'good':
                    annotationClass = 'annotation-good';
                    boardAnnotationType = 'good';
                    break;
                case 'acceptable':
                    annotationClass = 'annotation-acceptable';
                    break;
                case 'inaccuracy':
                    annotationClass = 'annotation-inaccuracy';
                    boardAnnotationType = 'inaccuracy';
                    break;
                case 'mistake':
                    annotationClass = 'annotation-mistake';
                    boardAnnotationType = 'mistake';
                    break;
                case 'blunder':
                    annotationClass = 'annotation-blunder';
                    boardAnnotationType = 'blunder';
                    break;
                default:
                    annotationClass = 'annotation-acceptable';
            }
            
            // Ajouter l'annotation sur l'√©chiquier si n√©cessaire
            if (boardAnnotationType) {
                // Obtenir la case de destination du coup
                const tempGame = new Chess();
                for (let i = 0; i < currentMoveIndex; i++) {
                    tempGame.move(moves[i].san);
                }
                const moveObj = tempGame.move(move.san);
                if (moveObj && moveObj.to) {
                    setTimeout(() => addMoveAnnotationToBoard(moveObj.to, boardAnnotationType), 100);
                }
            }

            moveInfo.innerHTML = `Coup ${move.moveNumber}: <strong>${move.san}</strong> ${annotation}`;

            // Mise √† jour de l'analyse d√©taill√©e
            let topMovesHtml = '';
            let bestLineHtml = '';
            
            if (move.topMoves && move.topMoves.length > 0) {
                topMovesHtml = '<div class="mt-3"><h6>üîç Meilleurs coups selon Stockfish :</h6>';
                topMovesHtml += '<div class="list-group list-group-flush">';
                
                // Cr√©er une position temporaire pour convertir les coups UCI en SAN
                const tempGame = new Chess();
                // Jouer tous les coups jusqu'√† la position AVANT le coup actuel
                for (let i = 0; i < currentMoveIndex; i++) {
                    try {
                        tempGame.move(moves[i].san);
                    } catch (e) {
                        console.error(`Erreur lors du coup ${i}: ${moves[i].san}`, e);
                        break;
                    }
                }
                
                move.topMoves.forEach((topMove, index) => {
                    const sanMove = uciToSan(topMove.move, tempGame);
                    const evaluationBadge = createEvaluationBadge(topMove.evaluation);
                    const rankNumber = index + 1;
                    const isBestMove = index === 0;
                    const itemClass = isBestMove ? 'list-group-item-success' : 'list-group-item-light';
                    
                    topMovesHtml += `
                        <div class="list-group-item ${itemClass} d-flex justify-content-between align-items-center py-2">
                            <div class="d-flex align-items-center">
                                <span class="badge bg-primary rounded-pill me-2">${rankNumber}</span>
                                <code class="fw-bold text-dark">${sanMove}</code>
                                ${isBestMove ? '<i class="bi bi-star-fill text-warning ms-2" title="Meilleur coup"></i>' : ''}
                            </div>
                            <div>
                                ${evaluationBadge}
                            </div>
                        </div>
                    `;
                });
                topMovesHtml += '</div></div>';
                
                
                // Afficher la variante appropri√©e selon le type d'erreur
                if (move.moveQuality === 'mistake' || move.moveQuality === 'blunder') {
                    // Pour les erreurs et gaffes, montrer comment l'adversaire peut exploiter l'erreur
                    if (move.opponentPunishment && move.opponentPunishment.pv_line && move.opponentPunishment.pv_line.length > 0) {
                        console.log('Affichage de la punition de l\'adversaire:', move.opponentPunishment.pv_line);
                        bestLineHtml = '<div class="mt-3 p-3 bg-danger-subtle rounded border border-danger">';
                        bestLineHtml += '<h6>‚öîÔ∏è Comment l\'adversaire exploite cette erreur :</h6>';
                        bestLineHtml += '<div class="d-flex align-items-center">';
                        bestLineHtml += '<div class="flex-grow-1">';
                        
                        // Formater la ligne de punition avec la notation correcte
                        let punishmentText = '';
                        move.opponentPunishment.pv_line.forEach((pv_move, idx) => {
                            if (pv_move.is_white) {
                                punishmentText += `${pv_move.move_number}. ${pv_move.san} `;
                            } else {
                                punishmentText += `${pv_move.san} `;
                            }
                        });
                        
                        bestLineHtml += `<code class="text-danger fw-bold">${punishmentText}</code>`;
                        bestLineHtml += '</div>';
                        bestLineHtml += `<button class="btn btn-sm btn-outline-danger ms-2" id="playPunishmentBtn-${currentMoveIndex}" data-move-index="${currentMoveIndex}">‚ñ∂ Voir la punition</button>`;
                        bestLineHtml += '</div>';
                        bestLineHtml += '</div>';
                    } else {
                        // Fallback vers la meilleure variante si pas de donn√©es de punition
                        const bestMove = move.topMoves[0];
                        if (bestMove && bestMove.pv_line && bestMove.pv_line.length > 0) {
                            bestLineHtml = '<div class="mt-3 p-3 bg-light rounded">';
                            bestLineHtml += '<h6>üéØ Meilleure variante (√† la place) :</h6>';
                            bestLineHtml += '<div class="d-flex align-items-center">';
                            bestLineHtml += '<div class="flex-grow-1">';
                            
                            let variationText = '';
                            bestMove.pv_line.forEach((pv_move, idx) => {
                                if (pv_move.is_white) {
                                    variationText += `${pv_move.move_number}. ${pv_move.san} `;
                                } else {
                                    variationText += `${pv_move.san} `;
                                }
                            });
                            
                            bestLineHtml += `<code class="text-primary">${variationText}</code>`;
                            bestLineHtml += '</div>';
                            bestLineHtml += `<button class="btn btn-sm btn-outline-primary ms-2" id="playVariantBtn-${currentMoveIndex}" data-move-index="${currentMoveIndex}">‚ñ∂ Jouer la variante</button>`;
                            bestLineHtml += '</div>';
                            bestLineHtml += '</div>';
                        }
                    }
                } else {
                    // Pour les autres types de coups, afficher la meilleure variante comme avant
                    const bestMove = move.topMoves[0];
                    console.log('Meilleur coup pour affichage:', bestMove);
                    
                    if (bestMove && bestMove.pv_line && bestMove.pv_line.length > 0) {
                        console.log('Affichage de la variante:', bestMove.pv_line);
                        bestLineHtml = '<div class="mt-3 p-3 bg-light rounded">';
                        bestLineHtml += '<h6>üéØ Meilleure variante :</h6>';
                        bestLineHtml += '<div class="d-flex align-items-center">';
                        bestLineHtml += '<div class="flex-grow-1">';
                        
                        // Formater la variante avec la notation correcte
                        let variationText = '';
                        bestMove.pv_line.forEach((pv_move, idx) => {
                            if (pv_move.is_white) {
                                variationText += `${pv_move.move_number}. ${pv_move.san} `;
                            } else {
                                variationText += `${pv_move.san} `;
                            }
                        });
                        
                        bestLineHtml += `<code class="text-primary">${variationText}</code>`;
                        bestLineHtml += '</div>';
                        bestLineHtml += `<button class="btn btn-sm btn-outline-primary ms-2" id="playVariantBtn-${currentMoveIndex}" data-move-index="${currentMoveIndex}">‚ñ∂ Jouer la variante</button>`;
                        bestLineHtml += '</div>';
                        bestLineHtml += '</div>';
                    } else {
                        console.log('Pas de variante disponible ou donn√©es manquantes');
                        // Afficher un message informatif m√™me sans pv_line
                        bestLineHtml = '<div class="mt-3 p-3 bg-light rounded">';
                        bestLineHtml += '<h6>üéØ Meilleure variante :</h6>';
                        bestLineHtml += '<div class="text-muted">';
                        bestLineHtml += '<small>Les donn√©es de variante ne sont pas disponibles. ';
                        bestLineHtml += '<br>Effectuez une re-analyse de la partie pour voir les variantes compl√®tes.</small>';
                        bestLineHtml += '</div>';
                        bestLineHtml += '</div>';
                    }
                }
            }

            // D√©terminer la couleur du badge selon la qualit√©
            let badgeColor = 'secondary';
            switch (move.moveQuality) {
                case 'best': badgeColor = 'success'; break;
                case 'good': badgeColor = 'primary'; break;
                case 'acceptable': badgeColor = 'info'; break;
                case 'inaccuracy': badgeColor = 'warning'; break;
                case 'mistake': badgeColor = 'orange'; break;
                case 'blunder': badgeColor = 'danger'; break;
            }

            currentMoveAnalysis.innerHTML = `
                <div class="move-analysis-detail">
                    <div class="text-center mb-4">
                        <h4>Coup ${move.moveNumber}: <code class="${annotationClass}">${move.san}</code> <span class="${annotationClass}" style="font-size: 1.5em;">${annotation}</span></h4>
                        <div class="badge bg-${badgeColor} fs-6">
                            ${qualityText}
                        </div>
                    </div>
                    
                    <div class="row text-center mb-3">
                        <div class="col-3">
                            <div class="p-3 border rounded">
                                <h6 class="text-muted mb-1">Avant le coup</h6>
                                <div>${createEvaluationBadge(move.evaluationBefore)}</div>
                            </div>
                        </div>
                        <div class="col-3">
                            <div class="p-3 border rounded">
                                <h6 class="text-muted mb-1">Apr√®s le coup</h6>
                                <div>${createEvaluationBadge(move.evaluationAfter)}</div>
                            </div>
                        </div>
                        <div class="col-3">
                            <div class="p-3 border rounded">
                                <h6 class="text-muted mb-1">Perte</h6>
                                <h5 class="${move.centipawnLoss > 0 ? 'text-warning' : 'text-success'}">${(move.centipawnLoss / 100.0 || 0).toFixed(2)} pions</h5>
                            </div>
                        </div>
                        <div class="col-3">
                            <div class="p-3 border rounded">
                                <h6 class="text-muted mb-1">Pr√©cision</h6>
                                <h5 class="${move.accuracy >= 90 ? 'text-success' : (move.accuracy >= 70 ? 'text-warning' : 'text-danger')}">${(move.accuracy || 100).toFixed(1)}%</h5>
                            </div>
                        </div>
                    </div>
                    
                    ${topMovesHtml}
                    ${bestLineHtml}
                </div>
            `;
            
            // Ajouter l'event listener pour le bouton de variante
            setTimeout(() => {
                const variantBtn = document.getElementById(`playVariantBtn-${currentMoveIndex}`);
                if (variantBtn) {
                    variantBtn.addEventListener('click', () => {
                        playBestLine(currentMoveIndex);
                    });
                }
                
                // Ajouter l'event listener pour le bouton de punition
                const punishmentBtn = document.getElementById(`playPunishmentBtn-${currentMoveIndex}`);
                if (punishmentBtn) {
                    punishmentBtn.addEventListener('click', () => {
                        playPunishmentLine(currentMoveIndex);
                    });
                }
            }, 100);
        }
    }

    function clearBoardAnnotations() {
        // Enlever tous les symboles textuels
        const boardElement = document.getElementById('chessboard');
        const symbols = boardElement.querySelectorAll('[data-square-symbol]');
        symbols.forEach(symbol => symbol.remove());
    }

    function goToMove(moveIndex) {
        // Reset du jeu
        game.reset();
        
        // Effacer les annotations pr√©c√©dentes
        clearBoardAnnotations();
        clearMoveArrows(); // Effacer aussi les fl√®ches pr√©c√©dentes
        
        // Jouer tous les coups jusqu'√† l'index demand√©
        for (let i = 0; i <= moveIndex && i < moves.length; i++) {
            try {
                game.move(moves[i].san);
            } catch (e) {
                console.error(`Erreur lors du coup ${i}: ${moves[i].san}`, e);
                break;
            }
        }
        
        currentMoveIndex = moveIndex;
        
        // Mettre √† jour l'√©chiquier ChessBoard.js
        board.position(game.fen());
        
        // Afficher une fl√®che pour le dernier coup jou√©
        if (moveIndex >= 0) {
            const history = game.history({ verbose: true });
            if (history.length > 0) {
                const lastMove = history[history.length - 1];
                highlightMove(lastMove.from, lastMove.to);
            }
        }
        
        // Ajouter l'annotation pour le coup actuel si n√©cessaire
        if (moveIndex >= 0) {
            const move = moves[moveIndex];
            const annotationType = getAnnotationType(move.centipawnLoss, move.isBestMove);
            
            if (annotationType && annotationType !== 'normal') {
                const lastMove = game.history({ verbose: true }).slice(-1)[0];
                if (lastMove) {
                    addMoveAnnotationToBoard(lastMove.to, annotationType);
                }
            }
        }
        
        // Mettre √† jour les informations du coup
        updateMoveInfo();
    }

    function getLastMoveFromSan(san) {
        // Extraire les cases de d√©part et d'arriv√©e du dernier coup
        const history = game.history({ verbose: true });
        if (history.length > 0) {
            const lastMove = history[history.length - 1];
            return [lastMove.from, lastMove.to];
        }
        return undefined;
    }

    // Fonction pour jouer automatiquement la ligne de punition de l'adversaire
    function playPunishmentLine(startMoveIndex) {
        console.log('playPunishmentLine appel√©e avec index:', startMoveIndex);
        
        if (startMoveIndex < 0 || startMoveIndex >= moves.length) {
            console.error('Index invalide:', startMoveIndex);
            return;
        }
        
        const move = moves[startMoveIndex];
        console.log('Coup s√©lectionn√© (gaffe):', move);
        
        const punishment = move.opponentPunishment;
        console.log('Donn√©es de punition:', punishment);
        
        if (!punishment) {
            alert('Aucune donn√©e de punition disponible');
            return;
        }
        
        if (!punishment.pv_line) {
            alert('Donn√©es de punition non disponibles. Une re-analyse de la partie est n√©cessaire.');
            return;
        }
        
        if (punishment.pv_line.length === 0) {
            alert('Ligne de punition vide');
            return;
        }
        
        console.log('Ligne de punition:', punishment.pv_line);
        
        // IMPORTANT: Aller √† la position APR√àS le coup de gaffe pour jouer la punition
        console.log('Position pour jouer la punition (apr√®s la gaffe):', startMoveIndex);
        
        // Reset du jeu et reconstruction de la position jusqu'au coup de gaffe inclus
        game.reset();
        
        // Jouer tous les coups jusqu'au coup de gaffe inclus
        for (let i = 0; i <= startMoveIndex && i < moves.length; i++) {
            try {
                console.log(`Reconstruction coup ${i}: ${moves[i].san}`);
                game.move(moves[i].san);
            } catch (e) {
                console.error(`Erreur lors de la reconstruction du coup ${i}: ${moves[i].san}`, e);
                break;
            }
        }
        
        console.log('Position apr√®s la gaffe reconstruite, FEN:', game.fen());
        
        // Mettre √† jour l'√©chiquier √† la position apr√®s la gaffe
        board.position(game.fen());
        currentMoveIndex = startMoveIndex;
        
        // Jouer la ligne de punition avec animation
        let punishmentMoveIndex = 0;
        const maxPunishmentMoves = Math.min(6, punishment.pv_line.length);
        
        console.log(`D√©but de la punition - ${maxPunishmentMoves} coups √† jouer`);
        
        const playNextPunishmentMove = () => {
            if (punishmentMoveIndex >= maxPunishmentMoves) {
                // Fin de la punition - ajouter un marqueur visuel
                setTimeout(() => {
                    alert('Fin de la ligne de punition. Voici comment l\'adversaire exploite votre erreur !');
                }, 500);
                return;
            }
            
            const punishmentMove = punishment.pv_line[punishmentMoveIndex];
            console.log(`Coup de punition ${punishmentMoveIndex + 1}:`, punishmentMove);
            console.log('Position actuelle avant le coup:', game.fen());
            
            try {
                // Jouer le coup dans le moteur d'√©checs
                const moveObj = game.move(punishmentMove.san);
                console.log('R√©sultat du coup de punition:', moveObj);
                
                if (moveObj) {
                    // Mettre √† jour l'√©chiquier avec animation
                    board.position(game.fen());
                    
                    // Afficher la fl√®che pour ce coup de punition
                    highlightMove(moveObj.from, moveObj.to);
                    
                    // Mettre √† jour l'information de coup
                    const moveInfo = document.getElementById('moveInfo');
                    moveInfo.innerHTML = `<strong class="text-danger">‚öîÔ∏è Punition:</strong> ${formatVariantMove(punishmentMove)} 
                                         <br><small class="text-muted">Coup ${punishmentMoveIndex + 1} - Comment l'adversaire exploite votre erreur</small>`;
                    
                    punishmentMoveIndex++;
                    
                    // Programmer le prochain coup avec un d√©lai
                    setTimeout(playNextPunishmentMove, 1000);
                } else {
                    console.error('Coup invalide dans la punition:', punishmentMove);
                    alert('Erreur: coup invalide dans la ligne de punition');
                }
            } catch (e) {
                console.error('Erreur lors de la lecture de la punition:', e);
                console.log('Coups l√©gaux disponibles:', game.moves());
                alert('Erreur lors de la lecture de la punition: ' + e.message);
            }
        };
        
        // Commencer la lecture apr√®s un court d√©lai
        setTimeout(playNextPunishmentMove, 500);
    }

    // Fonction pour jouer automatiquement la meilleure variante
    function playBestLine(startMoveIndex) {
        console.log('playBestLine appel√©e avec index:', startMoveIndex);
        
        if (startMoveIndex < 0 || startMoveIndex >= moves.length) {
            console.error('Index invalide:', startMoveIndex);
            return;
        }
        
        const move = moves[startMoveIndex];
        console.log('Coup s√©lectionn√©:', move);
        
        const bestMove = move.topMoves && move.topMoves[0];
        console.log('Meilleur coup:', bestMove);
        
        if (!bestMove) {
            alert('Aucun coup disponible');
            return;
        }
        
        if (!bestMove.pv_line) {
            alert('Donn√©es de variante non disponibles. Une re-analyse de la partie est n√©cessaire pour voir les variantes compl√®tes.');
            return;
        }
        
        if (bestMove.pv_line.length === 0) {
            alert('Variante vide');
            return;
        }
        
        console.log('Ligne principale:', bestMove.pv_line);
        
        // IMPORTANT: Aller √† la position AVANT le coup analys√© pour jouer la variante
        const positionBeforeMoveIndex = startMoveIndex - 1;
        console.log('Position de d√©part pour la variante:', positionBeforeMoveIndex);
        
        // Reset du jeu et reconstruction de la position avant le coup
        game.reset();
        
        // Jouer tous les coups jusqu'√† la position AVANT le coup analys√©
        for (let i = 0; i <= positionBeforeMoveIndex && i < moves.length; i++) {
            try {
                console.log(`Reconstruction coup ${i}: ${moves[i].san}`);
                game.move(moves[i].san);
            } catch (e) {
                console.error(`Erreur lors de la reconstruction du coup ${i}: ${moves[i].san}`, e);
                break;
            }
        }
        
        console.log('Position de d√©part reconstruite, FEN:', game.fen());
        
        // Mettre √† jour l'√©chiquier √† la position de d√©part
        board.position(game.fen());
        currentMoveIndex = positionBeforeMoveIndex;
        
        // Jouer la meilleure variante avec animation
        let variantMoveIndex = 0;
        const maxVariantMoves = Math.min(6, bestMove.pv_line.length);
        
        console.log(`D√©but de la variante - ${maxVariantMoves} coups √† jouer`);
        
        const playNextVariantMove = () => {
            if (variantMoveIndex >= maxVariantMoves) {
                // Fin de la variante - ajouter un marqueur visuel
                setTimeout(() => {
                    alert('Fin de la meilleure variante. Vous pouvez revenir en arri√®re pour comparer.');
                }, 500);
                return;
            }
            
            const variantMove = bestMove.pv_line[variantMoveIndex];
            console.log(`Coup ${variantMoveIndex + 1}:`, variantMove);
            console.log('Position actuelle avant le coup:', game.fen());
            
            try {
                // Jouer le coup dans le moteur d'√©checs
                const moveObj = game.move(variantMove.san);
                console.log('R√©sultat du coup:', moveObj);
                
                if (moveObj) {
                    // Mettre √† jour l'√©chiquier avec animation
                    board.position(game.fen());
                    
                    // Afficher la fl√®che pour ce coup de variante
                    highlightMove(moveObj.from, moveObj.to);
                    
                    // Mettre √† jour l'information de coup
                    const moveInfo = document.getElementById('moveInfo');
                    moveInfo.innerHTML = `<strong>Variante:</strong> ${formatVariantMove(variantMove)} 
                                         <br><small class="text-muted">Coup ${variantMoveIndex + 1} de la meilleure ligne</small>`;
                    
                    variantMoveIndex++;
                    
                    // Programmer le prochain coup avec un d√©lai
                    setTimeout(playNextVariantMove, 1000);
                } else {
                    console.error('Coup invalide dans la variante:', variantMove);
                    alert('Erreur: coup invalide dans la variante');
                }
            } catch (e) {
                console.error('Erreur lors de la lecture de la variante:', e);
                console.log('Coups l√©gaux disponibles:', game.moves());
                alert('Erreur lors de la lecture de la variante: ' + e.message);
            }
        };
        
        // Commencer la lecture apr√®s un court d√©lai
        setTimeout(playNextVariantMove, 500);
    }
    
    // Fonction auxiliaire pour formater un coup de variante
    function formatVariantMove(variantMove) {
        if (variantMove.is_white) {
            return `${variantMove.move_number}. ${variantMove.san}`;
        } else {
            return `${variantMove.move_number}... ${variantMove.san}`;
        }
    }

    function getAnnotationType(centipawnLoss, isBestMove) {
        if (isBestMove || centipawnLoss <= 10) {
            return centipawnLoss === 0 ? 'excellent' : 'normal';
        } else if (centipawnLoss <= 50) {
            return 'inaccuracy';
        } else if (centipawnLoss <= 100) {
            return 'mistake';
        } else {
            return 'blunder';
        }
    }

    // Fonction pour cr√©er un badge d'√©valuation (comme dans l'entra√Ænement)
    function createEvaluationBadge(centipawns) {
        // Convertir en pions
        const pawns = centipawns / 100.0;
        
        // D√©terminer la couleur du badge selon le signe
        const badgeClass = pawns >= 0 ? 'bg-light text-dark border border-secondary' : 'bg-dark text-white';
        const label = pawns >= 0 ? 'Blanc' : 'Noir';
        const sign = pawns >= 0 ? '+' : '';
        
        return `<span class="badge ${badgeClass}" title="Avantage pour les ${label}s">${sign}${pawns.toFixed(2)}</span>`;
    }

    // √âv√©nements des boutons
    document.getElementById('startBtn').addEventListener('click', () => {
        game.reset();
        board.position('start');
        currentMoveIndex = -1;
        clearBoardAnnotations();
        updateMoveInfo();
    });

    document.getElementById('prevBtn').addEventListener('click', () => {
        if (currentMoveIndex > -1) {
            goToMove(currentMoveIndex - 1);
        }
    });

    document.getElementById('nextBtn').addEventListener('click', () => {
        if (currentMoveIndex < moves.length - 1) {
            goToMove(currentMoveIndex + 1);
        }
    });

    document.getElementById('endBtn').addEventListener('click', () => {
        goToMove(moves.length - 1);
    });

    // Fonctions de navigation vers les erreurs (seulement du joueur analys√©)
    function findNextError(currentIndex, errorTypes = ['inaccuracy', 'mistake', 'blunder']) {
        for (let i = currentIndex + 1; i < moves.length; i++) {
            const move = moves[i];
            // V√©rifier que c'est une erreur ET que c'est le tour du joueur analys√©
            if (errorTypes.includes(move.moveQuality) && move.isWhiteMove === playerIsWhite) {
                return i;
            }
        }
        return -1; // Aucune erreur du joueur trouv√©e
    }

    function findPrevError(currentIndex, errorTypes = ['inaccuracy', 'mistake', 'blunder']) {
        for (let i = currentIndex - 1; i >= 0; i--) {
            const move = moves[i];
            // V√©rifier que c'est une erreur ET que c'est le tour du joueur analys√©
            if (errorTypes.includes(move.moveQuality) && move.isWhiteMove === playerIsWhite) {
                return i;
            }
        }
        return -1; // Aucune erreur du joueur trouv√©e
    }

    function findNextBlunder(currentIndex) {
        return findNextError(currentIndex, ['blunder']);
    }

    // √âv√©nements pour les boutons de navigation vers les erreurs
    document.getElementById('prevErrorBtn').addEventListener('click', () => {
        const prevErrorIndex = findPrevError(currentMoveIndex);
        if (prevErrorIndex !== -1) {
            goToMove(prevErrorIndex);
        } else {
            alert('Aucune erreur pr√©c√©dente trouv√©e');
        }
    });

    document.getElementById('nextErrorBtn').addEventListener('click', () => {
        const nextErrorIndex = findNextError(currentMoveIndex);
        if (nextErrorIndex !== -1) {
            goToMove(nextErrorIndex);
        } else {
            alert('Aucune erreur suivante trouv√©e');
        }
    });

    document.getElementById('nextBlunderBtn').addEventListener('click', () => {
        const nextBlunderIndex = findNextBlunder(currentMoveIndex);
        if (nextBlunderIndex !== -1) {
            goToMove(nextBlunderIndex);
        } else {
            alert('Aucune gaffe trouv√©e dans la suite de la partie');
        }
    });

    // Raccourcis clavier pour la navigation
    document.addEventListener('keydown', (e) => {
        // √âviter d'interf√©rer si l'utilisateur tape dans un champ
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }
        
        switch(e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                if (currentMoveIndex > -1) {
                    goToMove(currentMoveIndex - 1);
                }
                break;
            case 'ArrowRight':
                e.preventDefault();
                if (currentMoveIndex < moves.length - 1) {
                    goToMove(currentMoveIndex + 1);
                }
                break;
            case 'Home':
                e.preventDefault();
                game.reset();
                board.position('start');
                currentMoveIndex = -1;
                clearBoardAnnotations();
                updateMoveInfo();
                break;
            case 'End':
                e.preventDefault();
                goToMove(moves.length - 1);
                break;
            case 'e':
            case 'E':
                e.preventDefault();
                // Navigation vers la prochaine erreur
                const nextErrorIndex = findNextError(currentMoveIndex);
                if (nextErrorIndex !== -1) {
                    goToMove(nextErrorIndex);
                }
                break;
            case 'b':
            case 'B':
                e.preventDefault();
                // Navigation vers la prochaine gaffe (blunder)
                const nextBlunderIndex = findNextBlunder(currentMoveIndex);
                if (nextBlunderIndex !== -1) {
                    goToMove(nextBlunderIndex);
                }
                break;
        }
    });

    // Initialisation
    updateMoveInfo();
    
    console.log("Initialisation termin√©e avec succ√®s.");
    
    } catch(error) {
        console.error("Erreur lors de l'initialisation de l'analyse d'√©checs:", error);
        alert("Erreur JavaScript: " + error.message + "\nL'√©chiquier pourrait ne pas fonctionner correctement.");
    }
});

// Fonction pour g√©rer la barre de progression de l'analyse avec polling (version int√©gr√©e)
function startAnalysisProgressTracking(username, gameId) {
    const container = document.getElementById('analysisProgressContainer');
    const progressBar = document.getElementById('analysisProgressBar');
    const progressText = document.getElementById('analysisProgressText');
    const progressTitle = document.getElementById('progressTitle');
    const currentMoveSpan = document.getElementById('currentMove');
    const totalMovesSpan = document.getElementById('totalMoves');
    const errorsFoundSpan = document.getElementById('errorsFound');
    const progressIcon = document.getElementById('progressIcon');
    
    // Afficher la barre de progression
    container.style.display = 'block';
    
    // Scroll vers la barre de progression pour la rendre visible
    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    let pollInterval;
    
    // Fonction de polling pour v√©rifier la progression
    function pollProgress() {
        fetch(`/chessTrainer/progress-poll/${username}/${gameId}/`)
            .then(response => response.json())
            .then(data => {
                console.log('ÔøΩ Donn√©es de progression re√ßues:', data);
                
                // G√©rer le cas de timeout ou pas d'analyse en cours
                if (data.progress === -1) {
                    progressText.textContent = "Aucune analyse en cours";
                    progressTitle.textContent = "Analyse termin√©e";
                    progressIcon.className = "bi bi-exclamation-triangle text-warning me-2";
                    progressIcon.style.animation = "none";
                    
                    setTimeout(() => {
                        container.style.display = 'none';
                    }, 3000);
                    clearInterval(pollInterval);
                    return;
                }
                
                // Mettre √† jour la barre de progression
                progressBar.style.width = data.progress + '%';
                progressBar.textContent = Math.round(data.progress) + '%';
                progressText.textContent = data.message;
                currentMoveSpan.textContent = data.current_move;
                totalMovesSpan.textContent = data.total_moves;
                errorsFoundSpan.textContent = data.errors_count;
                
                // Changer l'ic√¥ne selon la progression
                if (data.progress >= 100) {
                    progressTitle.textContent = "Analyse termin√©e !";
                    progressIcon.className = "bi bi-check-circle-fill text-success me-2";
                    progressIcon.style.animation = "none";
                    
                    clearInterval(pollInterval);
                    setTimeout(() => {
                        container.style.display = 'none';
                        // Recharger la page pour voir les r√©sultats
                        window.location.reload();
                    }, 2000);
                } else {
                    // Mettre √† jour le titre avec des informations de progression
                    progressTitle.textContent = `Analyse de la partie ${gameId.substring(0, 8)}...`;
                }
            })
            .catch(error => {
                console.error('Erreur lors du polling:', error);
                progressText.textContent = "Erreur de connexion";
                progressTitle.textContent = "Erreur";
                progressIcon.className = "bi bi-exclamation-triangle text-danger me-2";
                progressIcon.style.animation = "none";
                
                // Cacher la barre en cas d'erreur
                setTimeout(() => {
                    container.style.display = 'none';
                }, 5000);
                clearInterval(pollInterval);
            });
    }
    
    // D√©marrer le polling toutes les 500ms
    pollInterval = setInterval(pollProgress, 500);
    
    // Premier appel imm√©diat
    pollProgress();
    
    // Gestionnaire pour le bouton de fermeture
    const cancelBtn = document.getElementById('cancelAnalysisBtn');
    if (cancelBtn) {
        cancelBtn.onclick = function() {
            clearInterval(pollInterval);
            container.style.display = 'none';
        };
    }
    
    // Retourner l'ID de l'intervalle pour pouvoir l'arr√™ter si besoin
    return pollInterval;
}

// Gestion SSE pour la re-analyse
document.addEventListener('DOMContentLoaded', function() {
    let currentEventSource = null;
    
    // Fonction pour mettre √† jour la progression du bouton avec barre color√©e
    function updateButtonProgress(button, percentage, text) {
        const progressBg = button.querySelector('.progress-background');
        const buttonText = button.querySelector('.button-text');
        const progressText = button.querySelector('.progress-percentage');
        
        // Mettre √† jour la barre de progression
        if (progressBg) {
            progressBg.style.width = percentage + '%';
            
            // Changer la couleur selon le pourcentage
            if (percentage < 25) {
                progressBg.className = 'progress-background position-absolute top-0 start-0 h-100 bg-danger';
            } else if (percentage < 50) {
                progressBg.className = 'progress-background position-absolute top-0 start-0 h-100 bg-warning';
            } else if (percentage < 75) {
                progressBg.className = 'progress-background position-absolute top-0 start-0 h-100 bg-info';
            } else {
                progressBg.className = 'progress-background position-absolute top-0 start-0 h-100 bg-success';
            }
        }
        
        // Mettre √† jour le texte
        if (buttonText) {
            buttonText.textContent = text;
        }
        
        // Afficher/masquer le pourcentage
        if (progressText) {
            if (percentage > 0) {
                progressText.textContent = ` (${percentage}%)`;
                progressText.style.display = 'inline';
            } else {
                progressText.style.display = 'none';
            }
        }
    }
    
    // Fonction pour d√©marrer le suivi SSE d'une analyse
    function startAnalysisTracking(username, gameId, button) {
        // Fermer la connexion pr√©c√©dente si elle existe
        if (currentEventSource) {
            currentEventSource.close();
        }
        
        // √âtablir la connexion SSE
        const eventUrl = `/chessTrainer/events/${username}/${gameId}/`;
        currentEventSource = new EventSource(eventUrl);
        
        currentEventSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            console.log('üì° √âv√©nement SSE re√ßu:', data);
            
            switch(data.type) {
                case 'connected':
                    console.log('‚úÖ Connexion SSE √©tablie');
                    updateButtonProgress(button, 0, 'Connexion √©tablie...');
                    break;
                    
                case 'progress':
                    // Mettre √† jour le bouton avec la progression
                    updateButtonProgress(button, data.progress, 'Analyse en cours');
                    break;
                    
                case 'finished':
                    console.log('üéâ Analyse termin√©e:', data.status);
                    
                    // Restaurer le bouton selon le statut
                    if (data.status === 'completed') {
                        // Progression √† 100% avec succ√®s
                        updateButtonProgress(button, 100, 'Termin√© !');
                        
                        // Changer la couleur du bouton pour le succ√®s
                        button.classList.remove('btn-secondary');
                        button.classList.add('btn-success');
                        
                        // Recharger apr√®s 2 secondes pour voir les nouveaux r√©sultats
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    } else {
                        // En cas d'erreur, restaurer le bouton
                        restoreButton(button);
                        alert('Erreur lors de l\'analyse: ' + data.message);
                    }
                    
                    // Fermer la connexion
                    currentEventSource.close();
                    currentEventSource = null;
                    break;
                    
                case 'timeout':
                    console.log('‚è∞ Timeout SSE');
                    restoreButton(button);
                    currentEventSource.close();
                    currentEventSource = null;
                    break;
            }
        };
        
        currentEventSource.onerror = function(error) {
            console.error('‚ùå Erreur SSE:', error);
            restoreButton(button);
            currentEventSource.close();
            currentEventSource = null;
        };
    }
    
    // Fonction pour restaurer l'√©tat original d'un bouton
    function restoreButton(button) {
        const progressBg = button.querySelector('.progress-background');
        const buttonText = button.querySelector('.button-text');
        const progressText = button.querySelector('.progress-percentage');
        
        // Restaurer la barre de progression
        if (progressBg) {
            progressBg.style.width = '0%';
            progressBg.className = 'progress-background position-absolute top-0 start-0 h-100 bg-success';
        }
        
        // Restaurer le texte
        if (buttonText) {
            buttonText.textContent = 'Re-analyser (v2.0 avec variantes)';
        }
        
        // Masquer le pourcentage
        if (progressText) {
            progressText.style.display = 'none';
        }
        
        button.disabled = false;
        button.classList.remove('btn-secondary', 'btn-success');
        button.classList.add('btn-warning');
    }
    
    // Gestionnaire pour le bouton de re-analyse
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('analyze-btn') || e.target.closest('.analyze-btn')) {
            e.preventDefault();
            
            const button = e.target.classList.contains('analyze-btn') ? e.target : e.target.closest('.analyze-btn');
            const username = button.getAttribute('data-username');
            const gameId = button.getAttribute('data-game-id');
            const action = button.getAttribute('data-action');
            
            console.log('üéØ Lancement re-analyse v2.0:', { username, gameId, action });
            
            // Changer l'√©tat du bouton pendant l'analyse
            updateButtonProgress(button, 0, 'Initialisation...');
            button.disabled = true;
            button.classList.remove('btn-warning');
            button.classList.add('btn-secondary');
            
            // D√©marrer le suivi SSE
            startAnalysisTracking(username, gameId, button);
            
            // Lancer l'analyse en arri√®re-plan
            const analysisUrl = `/chessTrainer/force-analyze/${username}/${gameId}/`;
            
            fetch(analysisUrl, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Erreur lors du lancement de l\'analyse');
                }
                console.log('‚úÖ Re-analyse v2.0 lanc√©e avec succ√®s');
            })
            .catch(error => {
                console.error('‚ùå Erreur lors du lancement de la re-analyse:', error);
                
                // Restaurer le bouton en cas d'erreur
                restoreButton(button);
                
                // Fermer la connexion SSE
                if (currentEventSource) {
                    currentEventSource.close();
                    currentEventSource = null;
                }
                
                alert('Erreur lors du lancement de la re-analyse: ' + error.message);
            });
        }
    });
});

{% endif %}
</script>

<style>
.text-orange {
    color: #fd7e14 !important;
}
.bg-orange {
    background-color: #fd7e14 !important;
}
</style>
{% endblock %}
